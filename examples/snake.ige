# setup initial state
TO|FE FE
00 40 00
TO|FF FE
00 00 00
FILL|00 00|40 00|40 41 41 # prevent running screen as code
FILL|00 FF|FF FF|00 00 00 # clear call stack

# VAR:HEAD_POS at FF 00
TO|FF 00
00 20 20
# VAR:APPLE_POS at FF 01
00 25 25

# VAR:BODY_LENGTH at FE 00
TO|FE 00
01 00 00

TO|FE FC # since the body is stored as a series of write instructions, go back
40 L:after_draw


# everything FE 01 and below is body position values

# main loop
TO|41 41
    # clear the screen
    D0 00 01
    00 40 40
    00 00 00

    # do the same to draw the apple
    3C L:APPLE_WRITE
    00 00 00
    A0 03 00
    B0 00 00
    A1 FF 01 # APPLE_POS
    00 03 00
    LABEL|APPLE_WRITE
    69 0D 0D # apple color

    1A L:not_eaten # IF head and apple are in same spot
    00 42 41
    A1 FF 00 # head pos
    00 03 00
    A1 FF 01 # apple pos
    00 03 00
    LABEL|not_eaten
    TO| X Y-
    
    # move all positions up using a copy area instruction
    # won't bother with copying only the snake length so im copying the whole row
    # ONLY goes down to FB to avoid overriding the screen position
    # copy upwards to avoid overriding 
    # this means we'll write the last body position to FE FA
    # and the color will be FE FB
    C0 FE 03
    00 FE FB
    00 FE 01

    # to only draw the correct body length, we'll write in a jump at FE 01 
    # value of the jump will be at FA 00, we'll then OR it with FE 00
    # first do body_length * 2 to properly subtract
    2B EA 00
    00 00 00
    A1 FE 00
    00 01 00
    A0 01 00
    02 00 00

    2D FA 00
    00 02 00
    A0 01 00
    FB 00 00
    A1 EA 00
    00 01 00
    
    3C FE 01
    00 00 00
    A0 03 00
    40 FE 00
    A1 FA 00
    00 03 00

    # the body
    # copy the current head position to top of list
    CA L:HEAD_WRITE
    00 FE FA
    B0 FE FB
    07 5E 28

    # to draw the body, we just jump to FE 01, since the body
    # is stored as a series of write instructions
    40 FE 01
    LABEL|after_draw
    TO| X Y-

    # we draw the head after the body so that we can see it
    # OR the value of the head with a write instruction
    3C L:HEAD_WRITE
    00 00 00
    A0 03 00
    B0 00 00
    A1 FF 00 # HEAD_POS
    00 03 00
    LABEL|HEAD_WRITE
    FF 00 00 # head color

    # time for user input
    # we use WASD for inputs

    # if the key is pressed, we want to jump to the appropriate method to handle that direction
    # if it's not pressed, then we jump
    FF AE 77 # w key
    40 43 41 # if pressed, jump to move body
    50 03 00 # otherwise, advance
    
    FF AE 61 # a key
    40 44 41
    50 03 00

    FF AE 73 # s key
    40 45 41
    50 03 00

    FF AE 64 # d key
    40 46 41
    50 03 00

    LABEL|after_move
    TO| X Y-

    # blit
    BB 00 00

    # return to start of loop
    40 41 41

# func:increase body length
TO|42 41
    # add to length of body
    2A FE 00
    00 00 00
    A1 FE 00
    00 01 00
    A0 01 00
    01 00 00

    # move apple
    2A E1 00
    00 01 00
    A1 FF 01
    00 03 00
    A0 03 00
    00 12 34

    # modulo apple Y
    2E E2 00
    00 02 00
    A1 E1 00
    00 03 00
    A0 01 00
    40 00 00

    # modulo apple X
    # first do an AND to isolate the X
    3A E3 00
    00 00 00
    A0 03 00
    00 FF 00
    A1 E1 00
    00 03 00

    # now we do the modulo
    2E E4 00
    00 01 00
    A1 E3 00
    00 01 00
    A0 01 00
    40 00 00

    # OR the two together and that's the new apple pos
    3C FF 01
    00 01 00
    A1 E4 00
    00 03 00
    A1 E2 00
    00 03 00

    # return (with a goto instruction) to main loop
    40 L:not_eaten

#funcs: move body
TO|43 41
    # up 
    2D FF 00
    00 01 00
    A1 FF 00
    00 03 00
    A0 01 00
    01 00 00

    # return to main loop after having moved
    40 L:after_move

TO|44 41
    # left
    2D FF 00
    00 01 00
    A1 FF 00
    00 03 00
    A0 02 00
    01 00 00

    40 L:after_move

TO|45 41
    # down
    # down and right are the easiest, just add 1 / hex 100
    # plus, for fun, we don't care about wrapping :D
    2A FF 00
    00 01 00
    A1 FF 00
    00 03 00
    A0 01 00
    01 00 00

    40 L:after_move

TO|46 41
    # right
    2A FF 00
    00 01 00
    A1 FF 00
    00 03 00
    A0 02 00
    01 00 00

    40 L:after_move