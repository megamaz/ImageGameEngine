# setup initial state
PATCH|FE FE|00 40 00
PATCH|FF FE|00 00 00
FILL|00 FF|FF FF|00 00 00 # clear call stack
FILL|00 00|40 00|40 41 41 # prevent running screen as code

FILL|41 41|50 50|00 00 00 # clear code area
FILL|FE 00|FE FD|00 00 00 # clear body stack

# VAR:HEAD_POS at FF 00
ATLABEL|FF 00|HEAD_POS
PATCH|FF 00|00 20 20

# VAR:APPLE_POS at FF 01
ATLABEL|FF 01|APPLE_POS
PATCH|FF 01|00 25 25

# VAR:BODY_LENGTH at FE 00
ATLABEL|FE 00|BODY_LENGTH
PATCH|FE 00|00 00 00

# since the body is stored as a series of write instructions, put an instruction to go back
PATCH|FE FC|40 L:after_draw
# everything FE 01 and below is body position values

# main loop
# this REL command isn't truly useful, it's just there to test that it works
REL|41 41
TO|00 00
ENDREL
    # clear the screen
    FLL 00 01 ; 00 40 40 ; 00 00 00

    # draw the apple using a sneaky OR with a write instruction
    BOR L:APPLE_WRITE ; 00 00 00
    VAL 03 00 ; WRT 00 00
    VAR L:APPLE_POS ; 00 03 00

    LABEL|APPLE_WRITE
    69 0D 0D # apple color

    # IF head and apple are (not) in same spot
    # 42 41 is where I put the function for eating an apple
    IFE L:not_eaten ; 00 42 41
    VAR L:HEAD_POS ; 00 03 00
    VAR L:APPLE_POS ; 00 03 00

    LABEL|not_eaten
    TO| X Y-
    
    # move all positions up using a copy area instruction
    # won't bother with copying only the snake length so im copying the whole row
    # ONLY goes down to FB to avoid overriding the screen position
    # copy upwards to avoid overriding 
    # this means we'll write the last body position to FE FA
    # and the color will be FE FB
    CAR FE 03 ; 00 FE FB ; 00 FE 01 ; 00 00 00

    # to only draw the correct body length, we'll write in a jump at FE 01 
    # value of the jump will be at FA 00, we'll then OR it with FE 00
    # first do body_length * 2 to properly subtract
    MUL EA 00 ; 00 00 00
    VAR L:BODY_LENGTH ; 00 01 00
    VAL 01 00 ; 02 00 00

    SUB FA 00 ; 00 02 00
    VAL 01 00 ; FB 00 00
    VAR EA 00 ; 00 01 00
    
    BOR FE 01 ; 00 00 00
    VAL 03 00 ; 40 L:BODY_LENGTH
    VAR FA 00 ; 00 03 00

    # the body
    # copy the current head position to top of list
    # we run into a problem since we're doing this *before* drawing the head
    # the value at L:HEAD_WRITE is some random instruction on the first loop
    # I don't wanna overcomplicate this, so I'll first AND it with a write instruction
    # that way even it now becomes a random write to 00 00, which we never jump back to
    AND L:HEAD_WRITE ; 00 00 00
    VAL 03 00 ; WRT FF FF
    VAR L:HEAD_WRITE ; 00 03 00

    # now we do the copy
    CAV L:HEAD_WRITE ; 00 FE FA
    WRT FE FB ; 07 5E 28

    # to draw the body, we just jump to FE 01, since the body
    # is stored as a series of write instructions
    GTO FE 01
    LABEL|after_draw # useful return point
    TO| X Y-

    # we draw the head after the body so that we can see it
    # use the same sneaky apple trick as earlier
    BOR L:HEAD_WRITE ; 00 00 00
    VAL 03 00 ; B0 00 00
    VAR L:HEAD_POS ; 00 03 00

    LABEL|HEAD_WRITE
    FF 00 00 # head color

    # time for user input
    # we use WASD for inputs

    # if the key is pressed, we want to jump to the appropriate method to handle that direction
    # if it's not pressed, then we jump
    FF AE 77 # w key
    GTO 43 41 # if pressed, jump to move body
    OFF 03 00 # otherwise, advance
    
    FF AE 61 # a key
    GTO 44 41
    OFF 03 00

    FF AE 73 # s key
    GTO 45 41
    OFF 03 00

    FF AE 64 # d key
    GTO 46 41
    OFF 03 00

    LABEL|after_move # useful return point (again)
    TO| X Y-

    # blit at 15fps (makes snake easier to control)
    BLT 00 $15

    # return to start of loop
    GTO 41 41

# function for eating an apple
TO|42 41
    # add to length of body
    # length of body is stored at FE 00
    # so we do whatever is at FE 00 + 1 and store it at FE 00
    ADD L:BODY_LENGTH ; 00 00 00
    VAR L:BODY_LENGTH ; 00 01 00
    VAL 01 00 ; 01 00 00

    # move apple
    # pretty arbitrary number, but creates good "random" movement after the modulo
    ADD E1 00 ; 00 01 00
    VAR L:APPLE_POS ; 00 03 00
    VAL 03 00 ; 00 12 34

    # modulo apple Y
    MOD E2 00 ; 00 02 00
    VAR E1 00 ; 00 03 00
    VAL 01 00 ; 40 00 00

    # modulo apple X
    # first do an AND to isolate the X
    AND E3 00 ; 00 00 00
    VAL 03 00 ; 00 FF 00
    VAR E1 00 ; 00 03 00

    # now we do the modulo
    MOD E4 00 ; 00 01 00
    VAR E3 00 ; 00 01 00
    VAL 01 00 ; 40 00 00

    # OR the two together and that's the new apple pos
    BOR L:APPLE_POS ; 00 01 00
    VAR E4 00 ; 00 03 00
    VAR E2 00 ; 00 03 00

    # return (with a goto instruction) to main loop
    GTO L:not_eaten

# move body functions
TO|43 41
    # up 
    SUB L:HEAD_POS ; 00 01 00
    VAR L:HEAD_POS ; 00 03 00
    VAL 01 00 ; 01 00 00

    # return to main loop after having moved
    GTO L:after_move

TO|44 41
    # left
    SUB L:HEAD_POS ; 00 01 00
    VAR L:HEAD_POS ; 00 03 00
    VAL 02 00 ; 01 00 00

    GTO L:after_move

TO|45 41
    # down
    # for fun, we don't care about wrapping :D
    # the reason I'm saying this is fun is because that means the snake can sneakily enter the game code, and start overwriting a bunch of useful data.
    # this usually ends up in a softlock, but it's still fun nonetheless.
    ADD L:HEAD_POS ; 00 01 00
    VAR L:HEAD_POS ; 00 03 00
    VAL 01 00 ; 01 00 00

    GTO L:after_move

TO|46 41
    # right
    ADD L:HEAD_POS ; 00 01 00
    VAR L:HEAD_POS ; 00 03 00
    VAL 02 00 ; 01 00 00

    GTO L:after_move